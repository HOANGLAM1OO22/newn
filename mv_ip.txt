private fun makeConverter(task: VideoTranscodingTask): Operator {
    // Step 1: detect transform needs
    val needRotate = task.getRotation() != task.getTranscodingRotation()
    val srcW = task.getVideoWidth()
    val srcH = task.getVideoHeight()

    // Step 2: size after rotation (swap if 90/270)
    val rotatedW = if (needRotate && (task.getRotation() % 180 != 0)) srcH else srcW
    val rotatedH = if (needRotate && (task.getRotation() % 180 != 0)) srcW else srcH

    // Step 3: compute scale and target
    val targetW = task.getTranscodingVideoWidth()
    val targetH = task.getTranscodingVideoHeight()

    // scale to make sure resized >= target in both dims
    val scale = maxOf(targetW.toFloat() / rotatedW, targetH.toFloat() / rotatedH)
    val scaledW = (rotatedW * scale).roundToInt()
    val scaledH = (rotatedH * scale).roundToInt()

    SLog.i(TAG, """makeConverter fixed:
        | src=${srcW}x${srcH} rot=$needRotate(${task.getRotation()})
        | rotated=${rotatedW}x${rotatedH}
        | scaled=${scaledW}x${scaledH}
        | target=${targetW}x${targetH}
    """.trimToOneLine())

    val converters = mutableListOf<ImgpConverter>()

    if (needRotate) converters += ImgpConverter(UniImgp.ofRotate())
    if (scale != 1f) converters += ImgpConverter(UniImgp.ofResize())
    converters += ImgpConverter(UniImgp.ofCrop()) // always safe to crop-center

    return Operator { ibuf, obuf ->
        var input = ibuf
        var output = obuf

        for ((index, converter) in converters.withIndex()) {
            val last = index == converters.lastIndex
            output = when (converter.imgpType) {
                ImgpType.ROTATE -> MediaBuffer.newImageAlloc().apply {
                    val newFmt = input.format.toMutableFormat()
                        .setCols(rotatedW)
                        .setRows(rotatedH)
                        .setRotation(getCorrectionRotation(task.getRotation(), task.getTranscodingRotation()))
                    setMediaFormat(newFmt)
                    if (last && obuf.isNotEmpty) setData(obuf.getData()) else asSharable()
                }.allocate().toMutable()

                ImgpType.RESIZE -> MediaBuffer.newImageAlloc().apply {
                    val newFmt = input.format.toMutableFormat()
                        .setCols(scaledW)
                        .setRows(scaledH)
                    setMediaFormat(newFmt)
                    if (last && obuf.isNotEmpty) setData(obuf.getData()) else asSharable()
                }.allocateMutable()

                ImgpType.CROP -> MediaBuffer.newImageAlloc().apply {
                    // always safe crop (center)
                    val x = ((scaledW - targetW) / 2).coerceAtLeast(0)
                    val y = ((scaledH - targetH) / 2).coerceAtLeast(0)
                    val cropRect = Rect(x, y, x + targetW, y + targetH)

                    val newFmt = input.format.toMutableFormat()
                        .setCols(targetW)
                        .setRows(targetH)
                        .setCropRect(cropRect)

                    setMediaFormat(newFmt)
                    if (last && obuf.isNotEmpty) setData(obuf.getData()) else asSharable()
                }.allocateMutable()

                else -> throw UnsupportedOperationException()
            }

            input = converter.run(input, output)
        }
        output
    }
}



===========

private fun makeConverter(task: VideoTranscodingTask): Operator {
    val srcW = task.getVideoWidth()
    val srcH = task.getVideoHeight()
    val srcRot = task.getRotation()
    val dstRot = task.getTranscodingRotation()
    val needRotate = srcRot != dstRot

    // --- step 1: compute size after rotation ---
    val rotatedW = if (needRotate && (srcRot % 180 != 0)) srcH else srcW
    val rotatedH = if (needRotate && (srcRot % 180 != 0)) srcW else srcH

    // --- step 2: target encoder size ---
    val targetW = task.getTranscodingVideoWidth()
    val targetH = task.getTranscodingVideoHeight()

    // --- step 3: uniform scale so resized >= target ---
    val scale = maxOf(
        targetW.toFloat() / rotatedW,
        targetH.toFloat() / rotatedH
    )
    val scaledW = (rotatedW * scale).roundToInt().coerceAtLeast(targetW)
    val scaledH = (rotatedH * scale).roundToInt().coerceAtLeast(targetH)

    SLog.i(TAG, """makeConverter fixed:
        | src=${srcW}x${srcH} rot=$srcRot → dstRot=$dstRot
        | rotated=${rotatedW}x${rotatedH}
        | scaled=${scaledW}x${scaledH}
        | target=${targetW}x${targetH}
    """.trimToOneLine())

    val converters = mutableListOf<ImgpConverter>()
    if (needRotate) converters += ImgpConverter(UniImgp.ofRotate())
    if (scale != 1f) converters += ImgpConverter(UniImgp.ofResize())
    converters += ImgpConverter(UniImgp.ofCrop())

    return Operator { ibuf, obuf ->
        var input = ibuf
        var output = obuf

        for ((index, converter) in converters.withIndex()) {
            val last = index == converters.lastIndex
            output = when (converter.imgpType) {

                ImgpType.ROTATE -> MediaBuffer.newImageAlloc().apply {
                    val newFmt = input.format.toMutableFormat()
                        .setCols(rotatedW)
                        .setRows(rotatedH)
                        .setRotation(
                            getCorrectionRotation(srcRot, dstRot)
                        )
                    setMediaFormat(newFmt)
                    if (last && obuf.isNotEmpty) setData(obuf.getData()) else asSharable()
                }.allocate().toMutable()

                ImgpType.RESIZE -> MediaBuffer.newImageAlloc().apply {
                    val newFmt = input.format.toMutableFormat()
                        .setCols(scaledW)
                        .setRows(scaledH)
                    setMediaFormat(newFmt)
                    if (last && obuf.isNotEmpty) setData(obuf.getData()) else asSharable()
                }.allocateMutable()

                ImgpType.CROP -> MediaBuffer.newImageAlloc().apply {
                    val cropX = ((scaledW - targetW) / 2).coerceAtLeast(0)
                    val cropY = ((scaledH - targetH) / 2).coerceAtLeast(0)
                    val cropRect = Rect(
                        cropX, cropY,
                        cropX + targetW, cropY + targetH
                    )
                    val newFmt = input.format.toMutableFormat()
                        .setCols(targetW)
                        .setRows(targetH)
                        .setCropRect(cropRect)
                    setMediaFormat(newFmt)
                    if (last && obuf.isNotEmpty) setData(obuf.getData()) else asSharable()
                }.allocateMutable()

                else -> throw UnsupportedOperationException()
            }

            SLog.i(TAG, "Stage=${converter.imgpType}  in=${input.format.cols}x${input.format.rows} → out=${output.format.cols}x${output.format.rows}")
            input = converter.run(input, output)
        }
        output
    }
}


===============

// Trong case ImgpType.ROTATE:
ImgpType.ROTATE -> {
    MediaBuffer.newImageAlloc().apply {
        val inFmt = input.format
        val rotDiff = getCorrectionRotation(task.getRotation(), task.getTranscodingRotation())

        val newFmt = inFmt.toMutableFormat().apply {
            // Chỉ SWAP khi quay ±90/270
            if ((rotDiff % 180) != 0) {
                setCols(inFmt.rows)
                setRows(inFmt.cols)
            } else {
                setCols(inFmt.cols)
                setRows(inFmt.rows)
            }
            setRotation(rotDiff)
        }
        setMediaFormat(newFmt)

        if (isLast && obuf.isNotEmpty) {
            setData(obuf.getData())
        } else {
            asSharable()
            setUsage(obuf.getTypedData(HardwareBuffer::class.java).usage)
        }
    }.allocate().toMutable()
}
