R·∫•t tuy·ªát üëè ‚Äî gi·ªù ch√∫ng ta b∆∞·ªõc sang **Commit 3**, b∆∞·ªõc refactor quan tr·ªçng nh·∫•t trong to√†n b√†i t·∫≠p *Video Rental Kata* ‚Äî b∆∞·ªõc **‚ÄúReplace Conditional with Polymorphism‚Äù** theo ƒë√∫ng tinh th·∫ßn *Martin Fowler ‚Äì Refactoring* v√† *Clean Code (Robert C. Martin)*.

---

## üéØ M·ª•c ti√™u Commit 3

> Lo·∫°i b·ªè `switch-case` kh·ªèi `Customer`
> ‚Üí Di chuy·ªÉn logic t√≠nh gi√° v√† ƒëi·ªÉm th∆∞·ªüng v√†o `Movie` (v√† `Price`)
> ‚Üí ƒê·∫°t thi·∫øt k·∫ø h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng, d·ªÖ m·ªü r·ªông, d·ªÖ test, kh√¥ng vi ph·∫°m **Open/Closed Principle (OCP)**.

---

## ‚öôÔ∏è Thi·∫øt k·∫ø m·ªõi (theo flow Martin Fowler)

### 1Ô∏è‚É£ `Movie` kh√¥ng c√≤n gi·ªØ `priceCode` d·∫°ng `int`, m√† d√πng **Price object**

### 2Ô∏è‚É£ T·∫°o **Price** l√† abstract class, v√† subclass:

`RegularPrice`, `NewReleasePrice`, `ChildrenPrice`

### 3Ô∏è‚É£ `Movie` ·ªßy quy·ªÅn (delegate) vi·ªác t√≠nh gi√° & ƒëi·ªÉm th∆∞·ªüng cho `Price`

### 4Ô∏è‚É£ `Customer` ch·ªâ g·ªçi `rental.getCharge()` v√† `rental.getFrequentRenterPoints()`

---

## üß± C·∫•u tr√∫c package

```
src/
 ‚îú‚îÄ‚îÄ Customer.java
 ‚îú‚îÄ‚îÄ Movie.java
 ‚îú‚îÄ‚îÄ Price.java
 ‚îú‚îÄ‚îÄ RegularPrice.java
 ‚îú‚îÄ‚îÄ NewReleasePrice.java
 ‚îú‚îÄ‚îÄ ChildrenPrice.java
 ‚îú‚îÄ‚îÄ Rental.java
 ‚îî‚îÄ‚îÄ RentalManager.java
```

---

## ‚úÖ Full Refactored Code (Commit 3 ‚Äì Clean Code)

### üé¨ Movie.java

```java
public class Movie {
    public static final int REGULAR = 0;
    public static final int NEW_RELEASE = 1;
    public static final int CHILDREN = 2;

    private final String title;
    private Price price;

    public Movie(String title, int priceCode) {
        this.title = title;
        setPriceCode(priceCode);
    }

    public int getPriceCode() {
        return price.getPriceCode();
    }

    public void setPriceCode(int priceCode) {
        switch (priceCode) {
            case REGULAR -> price = new RegularPrice();
            case NEW_RELEASE -> price = new NewReleasePrice();
            case CHILDREN -> price = new ChildrenPrice();
            default -> throw new IllegalArgumentException("Invalid price code: " + priceCode);
        }
    }

    public String getTitle() {
        return title;
    }

    /** Delegate charge calculation to Price subclass */
    public double getCharge(int daysRented) {
        return price.getCharge(daysRented);
    }

    /** Delegate frequent renter point calculation to Price subclass */
    public int getFrequentRenterPoints(int daysRented) {
        return price.getFrequentRenterPoints(daysRented);
    }
}
```

---

### üí∞ Price.java (abstract superclass)

```java
/**
 * Abstract Price class ‚Äî represents pricing strategy.
 * Each subclass defines its own charge rule.
 */
public abstract class Price {
    public abstract int getPriceCode();

    public abstract double getCharge(int daysRented);

    /** Default rule: 1 point per rental */
    public int getFrequentRenterPoints(int daysRented) {
        return 1;
    }
}
```

---

### üß© RegularPrice.java

```java
public class RegularPrice extends Price {

    @Override
    public int getPriceCode() {
        return Movie.REGULAR;
    }

    @Override
    public double getCharge(int daysRented) {
        double result = 2.0;
        if (daysRented > 2) {
            result += (daysRented - 2) * 1.5;
        }
        return result;
    }
}
```

---

### üÜï NewReleasePrice.java

```java
public class NewReleasePrice extends Price {

    @Override
    public int getPriceCode() {
        return Movie.NEW_RELEASE;
    }

    @Override
    public double getCharge(int daysRented) {
        return daysRented * 3.0;
    }

    @Override
    public int getFrequentRenterPoints(int daysRented) {
        // Bonus for 2+ days new release
        return (daysRented > 1) ? 2 : 1;
    }
}
```

---

### üßí ChildrenPrice.java

```java
public class ChildrenPrice extends Price {

    @Override
    public int getPriceCode() {
        return Movie.CHILDREN;
    }

    @Override
    public double getCharge(int daysRented) {
        double result = 1.5;
        if (daysRented > 3) {
            result += (daysRented - 3) * 1.5;
        }
        return result;
    }
}
```

---

### üéü Rental.java

```java
public class Rental {
    private final Movie movie;
    private final int daysRented;

    public Rental(Movie movie, int daysRented) {
        this.movie = movie;
        this.daysRented = daysRented;
    }

    public int getDaysRented() {
        return daysRented;
    }

    public Movie getMovie() {
        return movie;
    }

    /** Calculate rental charge by delegating to Movie */
    public double getCharge() {
        return movie.getCharge(daysRented);
    }

    /** Calculate frequent renter points by delegating to Movie */
    public int getFrequentRenterPoints() {
        return movie.getFrequentRenterPoints(daysRented);
    }
}
```

---

### üë§ Customer.java (now super clean)

```java
import java.util.Enumeration;
import java.util.Vector;

/**
 * Customer aggregates Rentals and produces statements.
 * Calculation logic is fully delegated.
 */
public class Customer {
    private final String name;
    private final Vector<Rental> rentals = new Vector<>();

    public Customer(String name) {
        this.name = name;
    }

    public void addRental(Rental rental) {
        rentals.add(rental);
    }

    public String getName() {
        return name;
    }

    public String statement() {
        double totalAmount = 0;
        int frequentRenterPoints = 0;
        StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n");

        Enumeration<Rental> elements = rentals.elements();
        while (elements.hasMoreElements()) {
            Rental rental = elements.nextElement();

            double thisAmount = rental.getCharge();
            frequentRenterPoints += rental.getFrequentRenterPoints();

            result.append("\t")
                    .append(rental.getMovie().getTitle())
                    .append("\t")
                    .append(thisAmount)
                    .append("\n");

            totalAmount += thisAmount;
        }

        result.append("Amount owed is ").append(totalAmount).append("\n");
        result.append("You earned ").append(frequentRenterPoints).append(" frequent renter points");
        return result.toString();
    }
}
```

---

### ‚ñ∂Ô∏è RentalManager.java (for manual run)

```java
public class RentalManager {
    public static void main(String[] args) {
        Customer customer = new Customer("Hong");

        customer.addRental(new Rental(new Movie("Inception", Movie.REGULAR), 3));
        customer.addRental(new Rental(new Movie("Oppenheimer", Movie.NEW_RELEASE), 2));
        customer.addRental(new Rental(new Movie("Frozen", Movie.CHILDREN), 4));

        System.out.println(customer.statement());
    }
}
```

---

## üßπ Clean Code Notes (Martin & Uncle Bob style)

| Principle                           | How It‚Äôs Applied                                                             |
| ----------------------------------- | ---------------------------------------------------------------------------- |
| **Single Responsibility Principle** | `Movie` handles pricing, `Customer` handles statement, `Rental` acts as link |
| **Open/Closed Principle**           | Easy to add `BestsellerPrice` later ‚Äî no switch modification                 |
| **Meaningful Names**                | `getCharge()`, `getFrequentRenterPoints()` clearly describe intention        |
| **Avoid Code Duplication**          | Calculation logic centralized in subclasses                                  |
| **Polymorphism over Conditionals**  | Each `Price` type defines its own behavior                                   |
| **Small Functions, Cohesion**       | Every method does one thing well                                             |

---

## üßæ Commit message suggestion

```
refactor: replace conditional with polymorphism via Price hierarchy for Movie pricing

- Introduced abstract class Price and subclasses RegularPrice, NewReleasePrice, ChildrenPrice
- Moved all charge and frequent renter point logic from Customer to Price classes
- Simplified Customer.statement() to use delegation
- Prepared for adding new movie types (e.g., Bestseller)
```

---

## ‚úÖ Expected result after commit

* All tests from **Commit 1** still PASS
* Code now completely polymorphic
* `Customer.statement()` clear, readable, and short
* Ready for **Commit 4**: Add `BestsellerPrice` easily with no code duplication

---

B·∫°n mu·ªën m√¨nh ti·∫øp t·ª•c **Commit 4 (feat: add Bestseller movie type with tests)** ngay sau ƒë√¢y kh√¥ng?
N√≥ s·∫Ω d·ª±a tr·ª±c ti·∫øp tr√™n ki·∫øn tr√∫c polymorphism n√†y (r·∫•t ng·∫Øn g·ªçn v√† ƒë·∫πp).
