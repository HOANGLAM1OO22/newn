private fun makeConverter(task: VideoTranscodingTask): Operator {
    if (SemSystemProperties.getBoolean("secmm.motionphoto.convert-to-copy", false)) {
        return Operator { ibuf, obuf ->
            val input = ibuf.getTypedData(HardwareBuffer::class.java)
            val output = obuf.getTypedData(HardwareBuffer::class.java)
            SharedBufferManager.copyHwBufferToHwBuffer(input, output)
            obuf
        }
    }

    val srcRot = task.getRotation()
    val dstRot = task.getTranscodingRotation()
    val isRequiredToRotate = srcRot != dstRot

    // handle swapped dimension
    val (rotatedWidth, rotatedHeight) = if (srcRot % 180 != 0) {
        task.getVideoHeight() to task.getVideoWidth()
    } else {
        task.getVideoWidth() to task.getVideoHeight()
    }

    val scale = maxOf(
        task.getTranscodingVideoWidth().toFloat() / rotatedWidth,
        task.getTranscodingVideoHeight().toFloat() / rotatedHeight
    )

    val isRequiredResize = scale != 1f
    val isRequiredToCrop = (rotatedWidth.toFloat() / rotatedHeight) != task.getTranscodingVideoRatio()

    SLog.i(TAG, """makeConverter:
        | src: ${task.getVideoWidth()}x${task.getVideoHeight()} rot=$srcRot
        | rotated: ${rotatedWidth}x${rotatedHeight}
        | dst: ${task.getTranscodingVideoWidth()}x${task.getTranscodingVideoHeight()} rot=$dstRot
        | scale=$scale, needRotate=$isRequiredToRotate, needResize=$isRequiredResize, needCrop=$isRequiredToCrop
    """.trimToOneLine())

    val converters = mutableListOf<ImgpConverter>()

    // ðŸ”¹ order: resize before rotate when 90/270 (to keep AR)
    if (srcRot == 90 || srcRot == 270) {
        if (isRequiredResize) converters += ImgpConverter(UniImgp.ofResize())
        if (isRequiredToRotate) converters += ImgpConverter(UniImgp.ofRotate())
    } else {
        if (isRequiredToRotate) converters += ImgpConverter(UniImgp.ofRotate())
        if (isRequiredResize) converters += ImgpConverter(UniImgp.ofResize())
    }
    if (isRequiredToCrop) converters += ImgpConverter(UniImgp.ofCrop())

    return Operator { ibuf, obuf ->
        var input = ibuf
        var output = obuf
        var dumpOnce = false

        for (imgpConverter in converters) {
            val isLast = imgpConverter == converters.last()

            output = when (imgpConverter.imgpType) {
                ImgpType.ROTATE -> {
                    SLog.i(TAG, "--- ROTATE ---")

                    val newRotation = getCorrectionRotation(srcRot, dstRot)
                    val rotatedFormat = input.format.toMutableFormat()

                    if (srcRot == 90 || srcRot == 270) {
                        rotatedFormat.setCols(input.format.rows)
                        rotatedFormat.setRows(input.format.cols)
                    }

                    // ðŸ”¹ When 180Â°, apply full flip and reset rotation to 0
                    if (srcRot == 180) {
                        rotatedFormat.setRotation(0)
                    } else {
                        rotatedFormat.setRotation(newRotation)
                    }

                    MediaBuffer.newImageAlloc().apply {
                        setMediaFormat(rotatedFormat)
                        if (isLast && obuf.isNotEmpty) setData(obuf.getData())
                        else {
                            asSharable()
                            setUsage(obuf.getTypedData(HardwareBuffer::class.java).usage)
                        }
                    }.allocateMutable()
                }

                ImgpType.RESIZE -> {
                    SLog.i(TAG, "--- RESIZE ---")
                    MediaBuffer.newImageAlloc().apply {
                        val newFormat = input.format.toMutableFormat().apply {
                            cols = (cols * scale).roundToNearestEven()
                            rows = (rows * scale).roundToNearestEven()
                        }
                        setMediaFormat(newFormat)
                        if (isLast && obuf.isNotEmpty) setData(obuf.getData())
                        else {
                            asSharable()
                            setUsage(obuf.getTypedData(HardwareBuffer::class.java).usage)
                        }
                    }.allocateMutable()
                }

                ImgpType.CROP -> {
                    SLog.i(TAG, "--- CROP ---")
                    MediaBuffer.newImageAlloc().apply {
                        val cropRect = computeCropRect(input.format, obuf.format)
                        val newFormat = obuf.format.toMutableFormat().setCropRect(cropRect)
                        setMediaFormat(newFormat)
                        if (isLast && obuf.isNotEmpty) setData(obuf.getData())
                        else {
                            asSharable()
                            setUsage(obuf.getTypedData(HardwareBuffer::class.java).usage)
                        }
                    }.allocateMutable()
                }

                else -> throw UnsupportedOperationException("Unsupported imgpType=${imgpConverter.imgpType}")
            }

            // ðŸ”¹ Physically perform flip for 180Â° rotation
            if (srcRot == 180 && imgpConverter.imgpType == ImgpType.ROTATE) {
                UniImgp.ofFlipHorizontal().run(input, output)
                UniImgp.ofFlipVertical().run(output, output)
            }

            input = imgpConverter.run(input, output)

            if (!dumpOnce && task.path().contains("145219")) {
                MediaBufferFileWriter("/sdcard/Download", "dump_${imgpConverter.imgpType.name.lowercase()}").write(input)
                dumpOnce = true
            }
        }

        output
    }
}
