OK ‚úÖ ‚Äî D∆∞·ªõi ƒë√¢y l√† **phi√™n b·∫£n full code** cho **C√°ch A (Bake rotation v√†o pixel, kh√¥ng d√πng metadata rotation)**,
ƒë∆∞·ª£c vi·∫øt l·∫°i **ho√†n ch·ªânh cho h√†m `makeConverter()` v√† block `ImgpType.ROTATE`** trong `VideoTranscoder`.

> üéØ M·ª•c ti√™u:
>
> * Native kh√¥ng c√≤n th·∫•y rows/cols = 1312√ó1312
> * Kh√¥ng c√≥ rotation attribute trong `MediaBuffer.format`
> * Encoder ƒë∆∞·ª£c config ƒë√∫ng width/height sau xoay, rotation=0
> * Output pixel th·ª±c s·ª± ƒë√£ ƒë∆∞·ª£c xoay (pixel-rotated)

---

### ‚úÖ `makeConverter()` (Full, ƒë√£ ch·ªânh ƒë√∫ng theo C√°ch A)

```kotlin
private fun makeConverter(task: VideoTranscodingTask): Operator {
    if (SemSystemProperties.getBoolean("secmm.motionphoto.convert-to-copy", false)) {
        return Operator { ibuf, obuf ->
            val input = ibuf.getTypedData(HardwareBuffer::class.java)
            val output = obuf.getTypedData(HardwareBuffer::class.java)
            SharedBufferManager.copyHwBufferToHwBuffer(input, output)
            obuf
        }
    }

    val srcRot = task.getRotation()
    val dstRot = task.getTranscodingRotation()
    val isRequiredToRotate = srcRot != dstRot

    // 1Ô∏è‚É£ T√≠nh k√≠ch th∆∞·ªõc sau khi xoay
    val (rotatedWidth, rotatedHeight) = if (srcRot % 180 != 0) {
        task.getVideoHeight() to task.getVideoWidth()
    } else {
        task.getVideoWidth() to task.getVideoHeight()
    }

    // 2Ô∏è‚É£ T√≠nh scale v√† crop
    val scale = maxOf(
        task.getTranscodingVideoWidth().toFloat() / rotatedWidth,
        task.getTranscodingVideoHeight().toFloat() / rotatedHeight
    )

    val isRequiredResize = scale != 1f
    val isRequiredToCrop =
        (rotatedWidth.toFloat() / rotatedHeight) != task.getTranscodingVideoRatio()

    SLog.i(TAG, """makeConverter:
        | src: ${task.getVideoWidth()}x${task.getVideoHeight()}, rot=$srcRot
        | rotated: ${rotatedWidth}x${rotatedHeight}
        | dst: ${task.getTranscodingVideoWidth()}x${task.getTranscodingVideoHeight()}, rot=$dstRot
        | scale=$scale, needRotate=$isRequiredToRotate, needResize=$isRequiredResize, needCrop=$isRequiredToCrop
    """.trimToOneLine())

    val converters = mutableListOf<ImgpConverter>()

    // 3Ô∏è‚É£ S·∫Øp x·∫øp th·ª© t·ª± filter h·ª£p l√Ω (xoay pixel th·∫≠t)
    if (srcRot == 90 || srcRot == 270) {
        if (isRequiredResize) converters += ImgpConverter(UniImgp.ofResize())
        if (isRequiredToRotate) converters += ImgpConverter(UniImgp.ofRotate())
    } else {
        if (isRequiredToRotate) converters += ImgpConverter(UniImgp.ofRotate())
        if (isRequiredResize) converters += ImgpConverter(UniImgp.ofResize())
    }
    if (isRequiredToCrop) converters += ImgpConverter(UniImgp.ofCrop())

    // 4Ô∏è‚É£ Chu·ªói Operator
    return Operator { ibuf, obuf ->
        var input = ibuf
        var output = obuf

        for (imgpConverter in converters) {
            val isLast = imgpConverter == converters.last()

            output = when (imgpConverter.imgpType) {

                ImgpType.ROTATE -> {
                    SLog.i(TAG, "--- ROTATE ---")

                    val correction = getCorrectionRotation(srcRot, dstRot) // e.g. 180->90
                    MediaBuffer.newImageAlloc().apply {
                        // üî• D√πng k√≠ch th∆∞·ªõc sau xoay: swap width/height
                        val newFormat = input.format
                            .toMutableFormat()
                            .setCols(input.format.rows) // swap
                            .setRows(input.format.cols)
                            .clearRotation() // custom ext: remove rotation attr completely

                        setMediaFormat(newFormat)

                        if (isLast && obuf.isNotEmpty) {
                            setData(obuf.getData())
                        } else {
                            asSharable()
                            setUsage(obuf.getTypedData(HardwareBuffer::class.java).usage)
                        }
                    }.allocateMutable().also { outBuf ->
                        // Truy·ªÅn g√≥c xoay cho plugin, kh√¥ng qua attributes
                        (imgpConverter as ImgpConverter).imgp.setRotationDegrees(correction)
                    }
                }

                ImgpType.RESIZE -> {
                    SLog.i(TAG, "--- RESIZE ---")
                    MediaBuffer.newImageAlloc().apply {
                        val newFormat = input.format.toMutableFormat().apply {
                            cols = (cols * scale).roundToNearestEven()
                            rows = (rows * scale).roundToNearestEven()
                        }.clearRotation()

                        setMediaFormat(newFormat)

                        if (isLast && obuf.isNotEmpty) setData(obuf.getData())
                        else {
                            asSharable()
                            setUsage(obuf.getTypedData(HardwareBuffer::class.java).usage)
                        }
                    }.allocateMutable()
                }

                ImgpType.CROP -> {
                    SLog.i(TAG, "--- CROP ---")
                    MediaBuffer.newImageAlloc().apply {
                        val cropRect = computeCropRect(input.format, obuf.format)
                        val newFormat = obuf.format
                            .toMutableFormat()
                            .setCropRect(cropRect)
                            .clearRotation()

                        setMediaFormat(newFormat)

                        if (isLast && obuf.isNotEmpty) setData(obuf.getData())
                        else {
                            asSharable()
                            setUsage(obuf.getTypedData(HardwareBuffer::class.java).usage)
                        }
                    }.allocateMutable()
                }

                else -> throw UnsupportedOperationException(
                    "Unsupported imgpType=${imgpConverter.imgpType}"
                )
            }

            try {
                input = imgpConverter.run(input, output)
            } catch (e: Exception) {
                SLog.e(TAG, "error during converting: ${e.message}, imgpType=${imgpConverter.imgpType}")
                e.printStackTrace()
            }
        }
        output
    }
}
```

---

### ‚úÖ Th√™m ti·ªán √≠ch m·ªü r·ªông: `clearRotation()` cho `MediaFormat`

Th√™m extension n√†y trong c√πng file ho·∫∑c file utils:

```kotlin
fun MutableMediaFormat.clearRotation(): MutableMediaFormat {
    if (has("rotation")) {
        remove("rotation")
    }
    return this
}
```

---

### ‚úÖ Trong `configVideoEncoderParameters()`, √©p encoder width/height theo sau xoay

Thay ƒë·ªïi nh∆∞ sau:

```kotlin
private fun configVideoEncoderParameters(format: MediaFormat, task: VideoTranscodingTask) {
    val srcRot = task.getRotation()
    val dstRot = task.getTranscodingRotation()
    val willBakeRotation = srcRot != dstRot

    val (rotatedW, rotatedH) = if (srcRot % 180 != 0) {
        task.getVideoHeight() to task.getVideoWidth()
    } else {
        task.getVideoWidth() to task.getVideoHeight()
    }

    if (willBakeRotation) {
        // Pixel ƒë√£ xoay ‚Üí encoder ph·∫£i config theo k√≠ch th∆∞·ªõc sau xoay
        format.setInteger(MediaFormat.KEY_WIDTH, rotatedW)
        format.setInteger(MediaFormat.KEY_HEIGHT, rotatedH)
        format.setInteger(MediaFormat.KEY_ROTATION, 0)
    } else {
        // Kh√¥ng c·∫ßn xoay
        format.setInteger(MediaFormat.KEY_WIDTH, task.getTranscodingVideoWidth())
        format.setInteger(MediaFormat.KEY_HEIGHT, task.getTranscodingVideoHeight())
        format.setInteger(MediaFormat.KEY_ROTATION, dstRot)
    }

    format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible)
    format.setFloat(MediaFormat.KEY_I_FRAME_INTERVAL, 0.5f)
    format.setInteger(MediaFormat.KEY_BIT_RATE, 10000000)
    format.setInteger(MediaFormat.KEY_PRIORITY, TRANSCODE_CODEC_PRIORITY)

    // vendor flags
    format.setInteger("vendor.qti-ext-enc-content-adaptive-mode.value", 1)
    format.setInteger("vendor.qti-ext-enc-linear-color-format.value", 1)
}
```

---

### ‚úÖ Trong `prepareEncoder()`, g·ªçi nh∆∞ sau:

```kotlin
val format = task.getTranscodingVideoCodecFormat()
configVideoEncoderParameters(format, task) // s·∫Ω t·ª± detect baked rotation
```

---

### ‚úÖ Trong `ImgpFilterAdapter` (n·∫øu b·∫°n c√≥ quy·ªÅn s·ª≠a):

Th√™m method m·ªõi ƒë·ªÉ truy·ªÅn g√≥c xoay **thay v√¨ ƒë·ªçc t·ª´ attributes**:

```kotlin
class ImgpFilterAdapter {
    private var rotateDegrees: Int = 0

    fun setRotationDegrees(degrees: Int) {
        this.rotateDegrees = degrees
    }

    fun run(input: MediaBuffer, output: MutableMediaBuffer): MutableMediaBuffer {
        // native g·ªçi plugin.rotate(rotateDegrees, input, output)
        return nativeRunRotate(input, output, rotateDegrees)
    }
}
```

---

### ‚úÖ K·∫øt qu·∫£ mong ƒë·ª£i log Native

Sau khi fix, log c·ªßa b·∫°n s·∫Ω chuy·ªÉn t·ª´:

```
shape=batch/rows/cols=[1 1312 1312 1]
```

üëâ sang:

```
ibuf: shape=batch/rows/cols=[1 1312 1752 1]
obuf: shape=batch/rows/cols=[1 1752 1312 1]
(no rotation attribute)
stride=1752, scanline=1312
```

v√† OpenCV log:

```
rotate_num=90
inputPlaneMat: 1312x1752
outputPlaneMat: 1752x1312
```

---

N·∫øu b·∫°n mu·ªën, t√¥i c√≥ th·ªÉ g·ª≠i th√™m:

* ‚úÖ **diff d·∫°ng commit git** (ƒë·ªÉ √°p th·∫≥ng v√†o branch)
* ‚úÖ **log verify expected**
* ‚úÖ **phi√™n b·∫£n native C++ check rotation clean**

B·∫°n c√≥ mu·ªën t√¥i t·∫°o lu√¥n commit patch d·∫°ng diff cho branch `dev/huong` kh√¥ng?
